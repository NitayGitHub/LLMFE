"""
[PREFIX]

###
<Task>
Predict the car purchase amount (in USD) a customer is likely comfortable spending, based on their demographic information and financial profile.

###
<Features>
[FEATURES]

###
<Examples>
[EXAMPLES]
[SUFFIX]
"""

@evaluate.run
def evaluate(data: dict):
    """ Evaluate the feature transformations on data observations."""

    from sklearn import preprocessing
    from sklearn.model_selection import StratifiedKFold, KFold
    from sklearn.metrics import root_mean_squared_error
    from preprocessing import preprocess_datasets
    import xgboost as xgb
    import torch
    import numpy as np

    # Load data observations
    label_encoder = preprocessing.LabelEncoder()
    inputs, outputs, is_cat, is_regression = data['inputs'], data['outputs'], data['is_cat'], data['is_regression']
    X = modify_features(inputs)
    y = outputs

    # Encode categorical string columns
    for col in X.columns:
        if X[col].dtype == 'string':
            X[col] = label_encoder.fit_transform(X[col])

    # Choose cross-validation strategy
    kf = KFold(n_splits=4, shuffle=True, random_state=42)

    scores = []

    # 4-Fold Cross-Validation
    for train_idx, test_idx in kf.split(X, y):
        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y[train_idx], y[test_idx]

        X_train_new, X_test_new = preprocess_datasets(X_train, X_test, None)
        
        # Convert to tensors
        X_train = torch.tensor(X_train_new.to_numpy())
        X_test = torch.tensor(X_test_new.to_numpy())
        y_train = torch.tensor(y_train)
        y_test = torch.tensor(y_test)
        
        # Load model
        model = xgb.XGBRegressor(random_state=42)

        model.fit(X_train, y_train)
        
        y_pred = model.predict(X_test)
        score = -1*root_mean_squared_error(y_test, y_pred)
        scores.append(score)

    # Calculate average score
    avg_score = np.mean(scores)

    return avg_score, inputs, outputs


@equation.evolve
def modify_features(df_input) -> pd.DataFrame:
    """
    Derived new features to enhance predictive power for the car purchase amount task.
    Combined age and annual salary to reflect experience/life stage and financial capability.
    Extracted creditworthiness and financial stability through net worth and annual salary relationships.
    Calculated purchasing power, financial stability, and age-weighted net worth for improved modeling.
    Considered the impact of age on creditworthiness and financial stability.
    
    New Features:
    - purchasing_power: age * annual Salary
    - creditworthiness: net worth / annual Salary
    - financial_stability: net worth * (annual Salary / 100000)
    - age_weighted_net_worth: age * net worth
    - age_creditworthiness: age * (net worth / annual Salary)
    - age_financial_stability: age * (net worth * (annual Salary / 100000))
    """
    import pandas as pd
    import numpy as np
    
    df_output = df_input.copy()
    
    # Calculate interaction between age and annual salary
    df_output['purchasing_power'] = df_output['age'] * df_output['annual Salary']
    
    # Extract creditworthiness and financial stability
    df_output['creditworthiness'] = df_output['net worth'] / df_output['annual Salary']
    df_output['financial_stability'] = df_output['net worth'] * (df_output['annual Salary'] / 100000)
    
    # Calculate age-weighted net worth for improved modeling
    df_output['age_weighted_net_worth'] = df_output['age'] * df_output['net worth']
    
    # Calculate age-weighted creditworthiness and financial stability
    df_output['age_creditworthiness'] = df_output['age'] * (df_output['net worth'] / df_output['annual Salary'])
    df_output['age_financial_stability'] = df_output['age'] * (df_output['net worth'] * (df_output['annual Salary'] / 100000))
    
    return df_output